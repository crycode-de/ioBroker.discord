{
  "version": 3,
  "sources": ["../src/commands.ts"],
  "sourcesContent": ["import { isDeepStrictEqual } from 'node:util';\n\nimport { boundMethod } from 'autobind-decorator';\n\nimport {\n  CacheType,\n  Collection,\n  CommandInteraction,\n  DiscordAPIError,\n  Guild,\n  GuildMember,\n  Interaction,\n  MessageOptions,\n} from 'discord.js';\nimport { SlashCommandBuilder } from '@discordjs/builders';\nimport { REST } from '@discordjs/rest';\nimport { Routes } from 'discord-api-types/v10';\n\nimport type { DiscordAdapter } from './main';\nimport { i18n } from './lib/i18n';\nimport {\n  getBasenameFromFilePathOrUrl,\n  getBufferAndNameFromBase64String,\n} from './lib/utils';\n\nexport interface CommandObjectConfig {\n  id: string;\n  alias: string;\n  name: string;\n  get: boolean;\n  set: boolean;\n}\n\n/**\n * Class for discord slash commands handling\n */\nexport class DiscordAdapterSlashCommands {\n\n  /**\n   * Reference to the adapter instance.\n   */\n  private adapter: DiscordAdapter;\n\n  /**\n   * Discord REST api interface.\n   */\n  private rest: REST = new REST({ version: '10' });\n\n  /**\n   * Command name for the get state command.\n   */\n  private cmdGetStateName: string = 'iob-get';\n\n  /**\n   * Command name for the set state command.\n   */\n  private cmdSetStateName: string = 'iob-set';\n\n  /**\n   * If commands are fully registered including their permissions.\n   */\n  private registerCommandsDone: boolean = false;\n\n  /**\n   * The last registered commands.\n   * Used to check if something changed an we need to register the commands again.\n   */\n  private lastCommandsJson: any[] | null = null;\n\n  /**\n   * Collection of configurations for objects with commands enabled.\n   */\n  private commandObjectConfig: Collection<string, CommandObjectConfig> = new Collection();\n\n  /**\n   * Timeout to trigger the delayed registration of the slash commands.\n   */\n  private triggerDelayedRegisterSlashCommandsTimeout: ioBroker.Timeout | null = null;\n\n  /**\n   * Set of well known values that will be interperted as true.\n   * This is extended by some localized strings at runtime.\n   * Used to determine true values from iob-set slash commands.\n   */\n  private wellKnownbooleanTrueValues: Set<string> = new Set(['true', 'on', 'yes', '1']);\n\n  constructor (adapter: DiscordAdapter) {\n    this.adapter = adapter;\n  }\n\n  /**\n   * When the adapter is Ready.\n   * Called by `adapter.onReady()` after some basic checks and setup.\n   */\n  public async onReady (): Promise<void> {\n    // apply custom command names if configured\n    if (this.adapter.config.cmdGetStateName) {\n      if (this.adapter.config.cmdGetStateName.match(/^[a-zA-Z][0-9a-zA-Z-_]{0,50}$/)) {\n        this.cmdGetStateName = this.adapter.config.cmdGetStateName;\n      } else {\n        this.adapter.log.warn(`Invalid custom get state command name '${this.adapter.config.cmdGetStateName}' provied! Using default 'iob-get'.`);\n      }\n    }\n    if (this.adapter.config.cmdSetStateName) {\n      this.cmdSetStateName = this.adapter.config.cmdSetStateName;\n      if (this.adapter.config.cmdSetStateName.match(/^[a-zA-Z][0-9a-zA-Z-_]{0,50}$/)) {\n        this.cmdSetStateName = this.adapter.config.cmdSetStateName;\n      } else {\n        this.adapter.log.warn(`Invalid custom set state command name '${this.adapter.config.cmdSetStateName}' provied! Using default 'iob-set'.`);\n      }\n    }\n\n    // setup REST interface\n    this.rest.setToken(this.adapter.config.token);\n\n    // check if commands are enabled\n    if (!this.adapter.config.enableCommands) {\n      return;\n    }\n\n    // add translated versions of true/on/yes to the set of well known boolean true values\n    this.wellKnownbooleanTrueValues.add(i18n.getString('true'))\n      .add(i18n.getString('on'))\n      .add(i18n.getString('yes'));\n\n    // setup interaction handler for commands\n    if (!this.adapter.client) {\n      throw new Error('Tried to setup interaction handler for commands, but client is not initialized!');\n    }\n    this.adapter.client.on('interactionCreate', this.onInteractionCreate);\n  }\n\n  /**\n   * Register the commands on discord, if enabled.\n   */\n  public async registerSlashCommands (): Promise<void> {\n    this.registerCommandsDone = false;\n\n    if (!this.adapter.client?.user) {\n      throw new Error('Discord client not available');\n    }\n\n    if (this.adapter.unloaded) return;\n\n    // check if commands are enabled and if not remove set commands\n    if (!this.adapter.config.enableCommands) {\n      this.adapter.log.debug('Commands not enabled');\n\n      // check for commands and remove them all\n      for (const [, guild] of this.adapter.client.guilds.cache) {\n        await this.removeGuildCommands(guild);\n      }\n\n      await this.removeGlobalCommands();\n\n      return;\n    }\n\n    const cmdGet = new SlashCommandBuilder()\n      .setName(this.cmdGetStateName)\n      .setDescription(i18n.getString('Get an ioBroker state value'));\n\n    const cmdSet = new SlashCommandBuilder()\n      .setName(this.cmdSetStateName)\n      .setDescription(i18n.getString('Set an ioBroker state value'));\n\n    // set default permissions to true - permissions are checked by the adapter later\n    cmdGet.setDefaultPermission(true);\n    cmdSet.setDefaultPermission(true);\n\n    // add options\n    cmdGet.addStringOption((opt) => {\n      opt.setName('state')\n        .setDescription(i18n.getString('The ioBroker state to get'))\n        .setRequired(true);\n      for (const [, objCfg] of this.commandObjectConfig) {\n        if (objCfg.get) {\n          opt.addChoices({\n            name: objCfg.name,\n            value: objCfg.alias,\n          });\n        }\n      }\n      return opt;\n    });\n\n    cmdSet.addStringOption((opt) => {\n      opt.setName('state')\n        .setDescription(i18n.getString('The ioBroker state to set'))\n        .setRequired(true);\n      for (const [, objCfg] of this.commandObjectConfig) {\n        if (objCfg.set) {\n          opt.addChoices({\n            name: objCfg.name,\n            value: objCfg.alias,\n          });\n        }\n      }\n      return opt;\n    });\n    cmdSet.addStringOption((opt) => {\n      return opt.setName('value')\n        .setDescription(i18n.getString('The value to set'))\n        .setRequired(true);\n    });\n\n    // build commands array\n    const commands: SlashCommandBuilder[] = [\n      cmdGet,\n      cmdSet,\n    ];\n\n    const commandsJson = commands.map((cmd) => cmd.toJSON());\n\n    // only update the commands if something has changed\n    if (!isDeepStrictEqual(commandsJson, this.lastCommandsJson)) {\n      this.adapter.log.debug('Commands needs to be updated');\n\n      if (this.commandObjectConfig.size === 0) {\n        this.adapter.log.warn('Commands are enabled but not configured for any state object! Use the custom configuration of a state object to activate commands on it.');\n      }\n\n      const numGet = this.commandObjectConfig.filter((c) => c.get === true).size;\n      const numSet = this.commandObjectConfig.filter((c) => c.set === true).size;\n\n      // register commands for all servers of the bot (guild commands are applied instant and may have permissions per user set)\n      for (const [, guild] of this.adapter.client.guilds.cache) {\n        try {\n          if (this.adapter.config.commandsGlobal) {\n            // global commands enabled, remove per guild commands\n            await this.removeGuildCommands(guild);\n\n          } else {\n            // commands per guild\n            await this.rest.put(Routes.applicationGuildCommands(this.adapter.client.user.id, guild.id), { body: commandsJson });\n            this.adapter.log.info(`Registered commands for server ${guild.name} (id:${guild.id}) (get: ${numGet}, set: ${numSet})`);\n          }\n\n        } catch (err) {\n          if (err instanceof DiscordAPIError && err.message === 'Missing Access'){\n            this.adapter.log.warn(`Error registering commands for server ${guild.name} (id:${guild.id}). Seams like the bot is missing the 'applications.commands' scope on the server. ${err}`);\n          } else {\n            this.adapter.log.warn(`Error registering commands for server ${guild.name} (id:${guild.id}): ${err}`);\n          }\n        }\n      }\n\n      // register global commands if enabled\n      try {\n        if (this.adapter.config.commandsGlobal) {\n          // global commands enabled\n          await this.rest.put(Routes.applicationCommands(this.adapter.client.user.id), { body: commandsJson });\n          this.adapter.log.info(`Registered global commands (get: ${numGet}, set: ${numSet})`);\n\n        } else {\n          // global command disabled\n          await this.removeGlobalCommands();\n        }\n\n      } catch (err) {\n        if (err instanceof DiscordAPIError && err.message === 'Missing Access') {\n          this.adapter.log.warn(`Error registering global commands. Seams like the bot is missing the 'applications.commands' scope on the server. ${err}`);\n        } else {\n          this.adapter.log.warn(`Error registering global commands: ${err}`);\n        }\n      }\n\n      // cache the commandsJson for the next call of `registerSlashCommands()`\n      this.lastCommandsJson = commandsJson;\n\n    } else {\n      this.adapter.log.debug('Commands seams to be up to date');\n    }\n\n    this.registerCommandsDone = true;\n  }\n\n\n  /**\n   * Remove registered global commands if any.\n   */\n  private async removeGlobalCommands (): Promise<void> {\n    if (!this.adapter.client?.user) {\n      throw new Error('Discord client not available');\n    }\n\n    try {\n      const globalCommands = await this.adapter.client.application?.commands.fetch();\n      if (this.adapter.unloaded) return;\n\n      if (globalCommands && globalCommands.size > 0) {\n        this.adapter.log.debug(`Currently ${globalCommands.size} global commands registered. Removing them...`);\n        await this.rest.put(Routes.applicationCommands(this.adapter.client.user.id), { body: [] });\n        this.adapter.log.info(`Removed global commands cause commands they are not used anymore.`);\n      }\n    } catch (err) {\n      if (err instanceof DiscordAPIError && err.message === 'Missing Access') {\n        this.adapter.log.warn(`Error while removing registered global commands. Seams like the bot is missing the 'applications.commands' scope on the server. ${err}`);\n      } else {\n        this.adapter.log.warn(`Error while removing registered global commands: ${err}`);\n      }\n    }\n  }\n\n  /**\n   * Remove registered guild commands if any.\n   * @param guild The guild.\n   */\n  private async removeGuildCommands (guild: Guild): Promise<void> {\n    if (!this.adapter.client?.user) {\n      throw new Error('Discord client not available');\n    }\n\n    try {\n      const guildCommands = await guild.commands.fetch();\n      if (this.adapter.unloaded) return;\n\n      if (guildCommands.size > 0) {\n        this.adapter.log.debug(`Currently ${guildCommands.size} commands registered for server ${guild.name}. Removing them...`);\n        await this.rest.put(Routes.applicationGuildCommands(this.adapter.client.user.id, guild.id), { body: [] });\n        this.adapter.log.info(`Removed commands for server ${guild.name} cause commands they are not used anymore.`);\n      }\n    } catch (err) {\n      if (err instanceof DiscordAPIError && err.message === 'Missing Access') {\n        this.adapter.log.warn(`Error while removing registered commands for server ${guild.name} (id:${guild.id}). Seams like the bot is missing the 'applications.commands' scope on the server. ${err}`);\n      } else {\n        this.adapter.log.warn(`Error while removing registered commands for server ${guild.name} (id:${guild.id}): ${err}`);\n      }\n    }\n  }\n\n  /**\n   * Setup an ioBroker object for discord slash commands.\n   * @param objId ID of the ioBroker object to set up.\n   * @param cfg Command configuration for the ioBroker object or null to remove a possibly existing configuration.\n   */\n  public setupCommandObject (objId: string, cfg: CommandObjectConfig | null): void {\n    // check if alias is already in use\n    if (cfg) {\n      const conflictingAlias = this.commandObjectConfig.find((coc) => coc.alias === cfg?.alias && coc.id !== cfg.id);\n      if (conflictingAlias) {\n        this.adapter.log.warn(`Command alias ${cfg.alias} of object ${cfg.id} already in use by object ${conflictingAlias.id}! ${cfg.id} will be ignored.`);\n        cfg = null;\n      }\n    }\n\n    // remove if commands are not enabled or alias conflict\n    if (!cfg) {\n      if (this.commandObjectConfig.has(objId)) {\n        this.commandObjectConfig.delete(objId);\n        this.triggerDelayedRegisterSlashCommands();\n      }\n      return;\n    }\n\n    // update only if changed\n    const currentCfg = this.commandObjectConfig.get(objId);\n    if (!isDeepStrictEqual(cfg, currentCfg)) {\n      this.adapter.log.debug(`Update command configuration for ${objId}: ${JSON.stringify(cfg)}`);\n      this.commandObjectConfig.set(objId, cfg);\n      this.triggerDelayedRegisterSlashCommands();\n    }\n  }\n\n  /**\n   * Initialize a delayed registration of the slash commands.\n   * Calls `registerSlashCommands()` five seconds after the last call of this method.\n   * If called again within the five seconds the timeout starts again.\n   *\n   * This is used to handle object changes better and concat multiple changed\n   * object configurations into a single API call.\n   *\n   * If the initial custom objects setup of the adapter isn't done, this method\n   * does nothing since the command registration is called during this explicit.\n   */\n  private triggerDelayedRegisterSlashCommands (): void {\n    // do nothing on init\n    if (!this.adapter.initialCustomObjectSetupDone) return;\n\n    if (this.triggerDelayedRegisterSlashCommandsTimeout) {\n      this.adapter.clearTimeout(this.triggerDelayedRegisterSlashCommandsTimeout);\n    }\n\n    this.adapter.setTimeout(() => {\n      this.triggerDelayedRegisterSlashCommandsTimeout = null;\n      this.adapter.log.debug('Starting delayed slash commands registration...');\n      this.registerSlashCommands();\n    }, 5000);\n  }\n\n  /**\n   * Handle interaction commands.\n   */\n  @boundMethod\n  private async onInteractionCreate (interaction: Interaction<CacheType>): Promise<void> {\n\n    // raw states enabled?\n    if (this.adapter.config.enableRawStates) {\n      // set raw state... not async here since it should not block!\n      const interactionJson = interaction.toJSON() as Record<string, unknown>;\n      if (interaction.isCommand()) {\n        interactionJson.options = interaction.options.data;\n      }\n      this.adapter.setState('raw.interactionJson', JSON.stringify(interactionJson, (_key, value) => typeof value === 'bigint' ? value.toString() : value), true);\n    }\n\n    // is it a command?\n    if (!interaction.isCommand()) return;\n\n    if (!interaction.deferred) {\n      await interaction.deferReply();\n    }\n\n    const { commandName, user } = interaction;\n\n    if (!this.registerCommandsDone) {\n      this.adapter.log.warn(`Got command ${commandName} but command registration is not done yet.`);\n      return;\n    }\n\n    this.adapter.log.debug(`Got command ${commandName} ${interaction.toJSON()}`);\n\n    const authCheckTarget = interaction.member instanceof GuildMember ? interaction.member : user;\n\n    switch (commandName) {\n      case this.cmdGetStateName:\n        // check user authorization (user should only be able to call the command if authorized but check it nevertheless to be sure)\n        if (this.adapter.checkUserAuthorization(authCheckTarget, { getStates: true })) {\n          // user authorized\n          await this.handleCmdGetState(interaction);\n        } else {\n          // user not authorized\n          this.adapter.log.warn(`User ${user.tag} (id:${user.id}) is not authorized to call /${commandName} commands!`);\n          await interaction.editReply(i18n.getString('You are not authorized to call this command!'));\n        }\n        break;\n\n      case this.cmdSetStateName:\n        // check user authorization (user should only be able to call the command if authorized but check it nevertheless to be sure)\n        if (this.adapter.checkUserAuthorization(authCheckTarget, { setStates: true })) {\n          // user authorized\n          await this.handleCmdSetState(interaction);\n        } else {\n          // user not authorized\n          this.adapter.log.warn(`User ${user.tag} (id:${user.id}) is not authorized to call /${commandName} commands!`);\n          await interaction.editReply(i18n.getString('You are not authorized to call this command!'));\n        }\n        break;\n\n      default:\n        this.adapter.log.warn(`Got unknown command ${commandName}!`);\n        await interaction.editReply(i18n.getString('Unknown command!'));\n    }\n  }\n\n  /**\n   * Try to get the ioBroker object and CommandObjectConfig for a given object alias.\n   * The object will be checked if it's a valid state object.\n   * @param objAlias The alias of the object.\n   * @param interaction The interaction for replies on errors.\n   * @returns Array containing the object and the config or null and null.\n   */\n  private async getObjectAndCfgFromAlias (objAlias: string | null, interaction: CommandInteraction<CacheType>): Promise<[ioBroker.StateObject | null, CommandObjectConfig | null]> {\n    // find the config for the requested object\n    const cfg = this.commandObjectConfig.find((coc) => coc.alias === objAlias);\n    if (!cfg) {\n      await interaction.editReply(i18n.getString('Object `%s` not found!', objAlias || ''));\n      return [null, null];\n    }\n\n    // get the object\n    const obj = await this.adapter.getForeignObjectAsync(cfg.id);\n    if (!obj) {\n      await interaction.editReply(i18n.getString('Object `%s` not found!', cfg.id));\n      return [null, null];\n    }\n    if (obj.type !== 'state') {\n      await interaction.editReply(i18n.getString('Object `%s` is not of type state!', cfg.id));\n      return [null, null];\n    }\n\n    return [obj, cfg];\n  }\n\n  /**\n   * Handler for \"get state\" slash commands.\n   * @param interaction The interaction which triggered this.\n   */\n  private async handleCmdGetState (interaction: CommandInteraction<CacheType>): Promise<void> {\n    const objAlias = interaction.options.getString('state');\n\n    const [obj, cfg] = await this.getObjectAndCfgFromAlias(objAlias, interaction);\n    if (!obj || !cfg) {\n      return;\n    }\n\n    const objCustom: ioBroker.CustomConfig | undefined = obj.common.custom?.[this.adapter.namespace];\n\n    // check if get allowed\n    if (!objCustom?.commandsAllowGet) {\n      await interaction.editReply(i18n.getString('Get not allowed for state `%s`!', cfg.id));\n      return;\n    }\n\n    // get the state\n    const state = await this.adapter.getForeignStateAsync(cfg.id);\n    if (!state) {\n      await interaction.editReply(i18n.getString('State `%s` not found!', cfg.id));\n      return;\n    }\n\n    // get the value depending on the state type\n    let val: string = '';\n\n    // an optional MessageOptions object for special cases (like sending files)\n    let msgOpts: MessageOptions | undefined = undefined;\n\n    // add unit if defined in the object\n    const unit = obj.common.unit ? ` ${obj.common.unit}` : '';\n\n    // add info about missing ack flag if configured so\n    const ack = objCustom.commandsShowAckFalse && !state.ack ? ` (_${i18n.getString('not acknowledged')}_)` : '';\n\n    if (obj.common.role === 'date' && ((obj.common.type === 'string' && typeof state.val === 'string') || (obj.common.type === 'number' && typeof state.val === 'number'))) {\n      // date values\n      const d = new Date(state.val);\n      val = d.toLocaleString(i18n.language, { dateStyle: 'full', timeStyle: 'long' });\n\n    } else if (obj.common.type === 'string' && objCustom.commandsStringSendAsFile && typeof state.val === 'string') {\n      // path or url to file or base64 encoded file\n      const b64data = getBufferAndNameFromBase64String(state.val);\n      if (b64data) {\n        // base64 encoded content\n\n        msgOpts = {\n          content: `${cfg.name}${ack}:`,\n          files: [{\n            attachment: b64data.buffer,\n            name: b64data.name,\n          }],\n        };\n        val = 'file:base64';\n\n      } else {\n        // file path or url\n\n        // remove file:// prefix\n        if (state.val.startsWith('file://')) {\n          state.val = state.val.slice(7);\n        }\n\n        msgOpts = {\n          content: `${cfg.name}${ack}:`,\n          files: [{\n            attachment: state.val,\n            name: getBasenameFromFilePathOrUrl(state.val),\n          }],\n        };\n        val = `file:${state.val}`;\n      }\n\n    } else {\n      // non special value\n      switch (obj.common.type) {\n        case 'boolean':\n          if (state.val) {\n            val = objCustom.commandsBooleanValueTrue || i18n.getString('true');\n          } else {\n            val = objCustom.commandsBooleanValueFalse || i18n.getString('false');\n          }\n          break;\n\n        case 'number':\n          // number values\n          const decimals = objCustom.commandsNumberDecimals || 0;\n          if (typeof state.val === 'number') {\n            val = state.val.toFixed(decimals);\n          } else if (state.val === null) {\n            val = '_NULL_';\n          } else {\n            val = state.val.toString() || 'NaN';\n          }\n          if (i18n.isFloatComma) {\n            val = val.replace('.', ',');\n          }\n          break;\n\n        default:\n          if (typeof state.val === 'string') {\n            val = state.val;\n          } else if (state.val === null) {\n            val = '_NULL_';\n          } else {\n            val = state.val.toString();\n          }\n      }\n    }\n\n    this.adapter.log.debug(`Get command for ${cfg.id} - ${val}${unit}${ack}`);\n\n    // send the value as reply to the user\n    try {\n      if (msgOpts) {\n        // message\n        await interaction.editReply(msgOpts);\n      } else {\n        // just text\n        await interaction.editReply(`${cfg.name}: ${val}${unit}${ack}`);\n      }\n    } catch (err) {\n      this.adapter.log.warn(`Error sending interaction reply for /${this.cmdGetStateName} command! ${err}`);\n    }\n  }\n\n  /**\n   * Handler for \"set state\" slash commands.\n   * @param interaction The interaction which triggered this.\n   */\n  private async handleCmdSetState (interaction: CommandInteraction<CacheType>): Promise<void> {\n    const objAlias = interaction.options.getString('state');\n\n    const [obj, cfg] = await this.getObjectAndCfgFromAlias(objAlias, interaction);\n    if (!obj || !cfg) {\n      return;\n    }\n\n    const objCustom: ioBroker.CustomConfig | undefined = obj.common.custom?.[this.adapter.namespace];\n\n    // check if set allowed\n    if (!objCustom?.commandsAllowSet) {\n      await interaction.editReply(i18n.getString('Set not allowed for state `%s`!', cfg.id));\n      return;\n    }\n\n    let valueStr = interaction.options.getString('value');\n    if (typeof valueStr !== 'string') {\n      await interaction.editReply(i18n.getString('No value provided!'));\n      return;\n    }\n\n    valueStr = valueStr.trim();\n\n    // add unit if defined in the object\n    const unit = obj.common.unit ? ` ${obj.common.unit}` : '';\n\n    let value: string | number | boolean;\n    let valueReply: string;\n\n    switch (obj.common.type) {\n      case 'boolean':\n        // parse as boolean value\n        valueStr = valueStr.toLowerCase();\n        if (valueStr === objCustom.commandsBooleanValueTrue?.toLowerCase() || this.wellKnownbooleanTrueValues.has(valueStr)) {\n          // true value form configures custom value or from well known boolean true values\n          value = true;\n          valueReply = objCustom.commandsBooleanValueTrue || i18n.getString('true');\n        } else {\n          // false value\n          value = false;\n          valueReply = objCustom.commandsBooleanValueFalse || i18n.getString('false');\n        }\n        break;\n\n      case 'number':\n        // parse as number (float) value\n        if (i18n.isFloatComma) {\n          valueStr = valueStr.replace(',', '.');\n        }\n        value = parseFloat(valueStr);\n\n        if (isNaN(value)) {\n          await interaction.editReply(i18n.getString('The given value is not a number!'));\n          return;\n        }\n\n        valueReply = value.toString();\n        if (i18n.isFloatComma) {\n          valueReply = valueReply.replace('.', ',');\n        }\n\n        // check min and max if configured\n        if (typeof obj.common.min === 'number' && value < obj.common.min) {\n          let min = obj.common.min.toString();\n          if (i18n.isFloatComma) {\n            min = min.replace('.', ',');\n          }\n          await interaction.editReply(i18n.getString('Value %s is below the allowed minium of %s!', `${valueReply}${unit}`, `${min}${unit}`));\n          return;\n        }\n        if (typeof obj.common.max === 'number' && value > obj.common.max) {\n          let max = obj.common.max.toString();\n          if (i18n.isFloatComma) {\n            max = max.replace('.', ',');\n          }\n          await interaction.editReply(i18n.getString('Value %s is above the allowed maximum of %s!', `${valueReply}${unit}`, `${max}${unit}`));\n          return;\n        }\n\n        break;\n\n      default:\n        // string values\n        value = valueStr;\n        valueReply = valueStr;\n    }\n\n    this.adapter.log.debug(`Set command for ${cfg.id} - ${value}${unit}`);\n\n    // set the state\n    try {\n      await this.adapter.setForeignStateAsync(cfg.id, value, !!objCustom.commandsSetWithAck);\n    } catch (err) {\n      this.adapter.log.warn(`Error while setting state ${cfg.id} to ${value}! ${err}`);\n      await interaction.editReply(i18n.getString('Error while setting the state value!'));\n      return;\n    }\n\n    // send reply\n    await interaction.editReply(`${cfg.name}: ${valueReply}${unit}`);\n  }\n\n  /**\n   * Write a summay of all currently for commands configured objects to the log.\n   */\n  public logConfiguredCommandObjects (): void {\n    this.adapter.log.info('Configured state objects for discord slash commands:');\n    for (const [, cmdObjCfg] of this.commandObjectConfig) {\n      this.adapter.log.info(` |- ${cmdObjCfg.id} - alias:${cmdObjCfg.alias}, name:${cmdObjCfg.name}, get:${cmdObjCfg.get}, set:${cmdObjCfg.set}`);\n    }\n    this.adapter.log.info('---');\n  }\n}\n"],
  "mappings": "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",
  "names": []
}
